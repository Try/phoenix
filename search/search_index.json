{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"phoenix \u2013 Documentation","text":"<p>Quote</p> <p>The phoenix project aims to re-implement file formats used by the ZenGin made by Piranha Bytes for their early-2000s games Gothic and Gothic II. It is heavily based on ZenLib which is used as an initial reference implementation of the file formats.</p> <p>Welcome to the joint phoenix and ZenGin reference documentation. Here you will find information about how to use the phoenix library to parse ZenGin files as well as in-depth descriptions of the file formats being used.</p> <p>The Library Reference contains information relevant for users of the phoenix library while the ZenGin Reference contains detailed information about each file format and the ZenGin itself.</p>"},{"location":"engine/datatypes/","title":"Datatype Reference","text":"<p>This page contains a set of commonly used datatypes and their definition.</p> Datatype Size Description <code>byte</code> 1 A single, unsigned 8-bit integer <code>char</code> 1 A single, 8-bit integer representing a string character <code>short</code> 2 A single, signed 16-bit integer <code>ushort</code> 2 A single, unsigned 16-bit integer <code>int</code> 4 A single, signed 32-bit integer <code>uint</code> 4 A single, unsigned 32-bit integer <code>float</code> 4 A single, IEEE 754 floating point number <code>string</code> * A set of Windows-1252 encoded characters of dynamic length,terminated by <code>\\0</code> or <code>0x0A</code> (exceptions are documented) <code>zVEC2</code> 8 A set of two <code>float</code>s describing a 2-dimensional vector of the form <code>(x, y)</code> <code>zVEC3</code> 12 A set of three <code>float</code>s describing a 3-dimensional vector of the form <code>(x, y, z)</code> <code>zVEC4</code> 16 A set of four <code>float</code>s describing a 4-dimensional vector or quaternion of the form <code>(x, y, z, w)</code> <code>zTBBox3D</code> 24 A set of two <code>zVEC3</code>s describing a 3-dimensional bounding box of the form <code>(min, max)</code> <code>zDATE</code> 16 A structure describing a date: <code>struct {int year; ushort month, day, hour, minute, second; byte _padding[2];}</code>"},{"location":"engine/overview/","title":"ZenGin Reference","text":"<p>Welcome to the open ZenGin reference documentation. This page contains information about file formats used by the ZenGin, an early 2000's game engine developed by Piranha Bytes for the games Gothic and Gothic II.</p>"},{"location":"engine/overview/#prerequisites","title":"Prerequisites","text":"<p>To properly understand this documentation, a good understanding of binary data and operations as well as the C programming language is highly useful. Experience with other data exchange formats such as JSON and XML might also be helpful.</p>"},{"location":"engine/encodings/binary-chunked/","title":"Chunked Binary Encoding","text":"<p>Quick Infos</p> <p>Type: Encoding Class Name: <code>zCFileBIN</code> Used By: <code>zCModelAni</code></p> <p>Many asset files are encoded in binary, splitting the data up into sections called chunks. Each chunk consists of a type identifier, its size and the actual data wrapped inside it. Files using the chunked binary encoding do not contain data outside of chunks.</p> File Structure<pre><code>struct zCFileBIN {\nzCFileBIN_Chunk chunks[];\n}\nstruct zCFileBIN_Chunk {\nushort type;\nuint size;\nbyte data[/* size */];\n};\n</code></pre> <p>It should be noted that, apart from the data being grouped into chunks, files encoded in chunked binary behave the same as flat binary files.</p>"},{"location":"engine/encodings/binary-chunked/#representation","title":"Representation","text":"<p>Wherever the chunked binary format is used in asset format references, the chunks are represented in a tabbed list. To keep it concise, the names of the tabs contain the chunk type and their content contains a C-style struct defining the data stored within.</p> <code>0x1000</code><code>0x1010</code> Section 0x1000<pre><code>struct MyClass_Section1 {\nuint myValue1;\n// ...\n};\n</code></pre> <p>This tab describes the section with type <code>0x1000</code>. As declared in the struct above, it only contains a 32-bit unsigned integer. The definition of all datatypes can be found in the Datatype Reference.</p> Section 0x1010<pre><code>struct MyClass_Section2 {\nstring myValue2;\n// ...\n};\n</code></pre> <p>This tab describes the section with type <code>0x1010</code>. As you can see, it works the same as the first tab.</p> <p>You may have noticed, that the chunk's size is not mentioned anywhere in these tabs. While it should be taken as the actual size of the chunk, this reference aims to be as complete as possible, so the size of the struct provided for each section should be the same as the chunk size. If it is not, there is an error in this documentation.</p>"},{"location":"engine/encodings/binary/","title":"Binary Encoding","text":"<p>Quick Infos</p> <p>Type: Encoding Class Name: <code>zFILE</code> Used By: <code>zCFileBIN</code>, <code>zCFont</code>, <code>zCTexture</code>, <code>zFILE_VDFS</code></p> <p>Most asset files and other encodings are based flat binary files. As their name indicates, files encoded using flat binary just contain raw bytes. Their structure is fully defined by the asset format using the encoding.</p> <p>Binary files and other encodings based on them are little-endian.</p>"},{"location":"engine/encodings/binary/#representation","title":"Representation","text":"<p>Wherever binary data needs to be represented in a structured form, C-style structs are used. In this documentation, they are intended to be read without any sort of padding (see below). All primitive datatypes and how they should be read are documented in the Datatype Reference.</p> Example Binary Data<pre><code>struct Example {\nushort checksum;\nbyte type;\n};\nstatic_assert(sizeof(Example) == 3, \"A ushort is 2 bytes plus a byte is 3 bytes\");\n</code></pre> <p>Often, binary structures contain arrays of dynamic size. In order to allow for more fluent definitions, the C-style array declaration syntax is used. The variable containing the dynamic size of the array is put in a comment within the brackets.</p> Example Binary Data Containing Arrays<pre><code>struct Example {\nuint staticArray[10]; //&lt; A set of 10 consecutive uints\nushort dynamicLength;\nbyte dynamicArray[/* dynamicLength */]; //&lt; A set of `dynamicLength` consecutive bytes\n};\n</code></pre>"},{"location":"engine/formats/animation/","title":"ZenGin Animations","text":"<p>Quick Infos</p> <p>Type: Asset Format Format Name: Model Animation File Extension: <code>.MAN</code> Class Name: <code>zCModelAni</code> Encoding: Binary, Chunked</p> <p>ZenGin animation files contain skeletal animations for rigged meshes. Each file contains the data for one animation, including metadata and animation samples.</p> <p>Animations are found within the <code>Anims.vdf</code> file found in the <code>Data/</code> directory in the Gothic installation.</p>"},{"location":"engine/formats/animation/#format-description","title":"Format Description","text":"<p>Model animations are stored in a chunked binary file which contains the following chunks. Also refer to the Datatype Reference for general information about often used datatypes.</p> <code>0xA000</code><code>0xA010</code><code>0xA020</code><code>0xA030</code><code>0xA090</code> Marker Chunk<pre><code>struct zCModelAni_Marker {\n};\n</code></pre> <p>The marker chunks marks the beginning of a model animation file.</p> Source Chunk<pre><code>struct zCModelAni_Source {\nzDATE date; // Broken. See below.\nstring sourcePath;\nstring sourceScript;\n};\n</code></pre> <p>This source chunks was originally written to the file using a function called <code>zCFileBIN::WriteBinSrcFileStats</code>. It has a bug which causes it to use an uninitialized <code>zDATE</code> and write it to the output file. This is why the values in the date don't make any sense. Tread with care.</p> Header Chunk<pre><code>struct zCModelAni_Header {\nushort version;\nstring name;\nuint layer;\nuint numFrames;\nuint numNodes;\nfloat fps;\nfloat fpsSource;\nfloat samplePositionMin;\nfloat samplePositionScale;\nzTBBox3D bounds;\nstring next;\n};\n</code></pre> Events Chunk<pre><code>struct zCModelAni_Events {\nuint numEvents;\nzCModelAni_Events_Entry entries[/* numEvents */];\n};\nstruct zCModelAni_Events_Entry {\nuint type;\nuint number;\nstring tag;\nstring content[4];\nfloat values[4];\nfloat probability;\n};\n</code></pre> Samples Chunk<pre><code>struct zCModelAni_Samples {\nuint checksum;\nuint nodeIndices[/* zCModelAni_Header.numNodes */];\nstruct zTMdl_AniSample {\nushort rotation[3];\nushort position[3];\n} samples[/* zCModelAni_Header.numNodes * zCModelAni_Header.numFrames */];\n};\n</code></pre> <p>The <code>zCModelAni.checksum</code> field is used to match compatible the animation to a specific model. It is the same for assets belonging to the same model. Linked assets are <code>zCModelAni.checksum</code>, <code>zCModelMeshLib.checksum</code> and <code>zCModelHierarchy.checksum</code>.</p> <p>It is important to understand that the animation samples do not contain the actual values for the rotation and position. To save on memory and disk space consumption, the values are packed into shorts which are converted back to floats on demand. See Sample Positions and Sample Rotations for more information.</p>"},{"location":"engine/formats/animation/#sample-positions","title":"Sample Positions","text":"<p>The positions are represented as multiples of <code>zCModelAni_Header.samplePositionScale</code>. The formula for packing a given <code>zVEC3</code> position into the stored format can be summarized like this:</p> \\[     \\begin{bmatrix}         x_{p} \\\\         y_{p} \\\\         z_{p}     \\end{bmatrix}     =     \\Bigg(-v_{min} +     \\begin{bmatrix}         x \\\\         y \\\\         z     \\end{bmatrix}     \\Bigg) \\cdot \\frac{65535}{v_{max} - v_{min}} \\] <p>where \\(v_{min}\\) is the smallest value across all components of all sample positions of the animation and \\(v_{max}\\) is the maximum value. The output vector \\(\\begin{smallmatrix}x_{p} \\\\ y_{p} \\\\ z_{p} \\end{smallmatrix}\\) then contains a scaled representation of the input vector \\(\\begin{smallmatrix}x \\\\ y \\\\ z\\end{smallmatrix}\\) as three 16-bit unsigned integers. This operation is performed by <code>zCModelAni::AddTrafoMatrix</code> and <code>zTMdl_AniSample::PackTrans</code>.</p> <p>Alongside these packed positions, both \\(v_{min}\\) and the constant \\(s = (\\frac{65535}{v_{max} - v_{min}})^{-1}\\) are saved as <code>zCModelAni_Header.samplePositionMin</code> and <code>zCModelAni_Header.samplePositionScale</code> respectively. Thus, to convert the stored position back to its floating point representation, the following calculation may be applied:</p> \\[     \\begin{bmatrix}         x \\\\         y \\\\         z     \\end{bmatrix}     =      \\begin{bmatrix}         x_{p} \\\\         y_{p} \\\\         z_{p}     \\end{bmatrix}     \\cdot s + v_{min} \\] <p>where \\(x_{p}\\) , \\(y_{p}\\) and \\(z_{p}\\) are <code>zTMdl_AniSample.position[0]</code>, <code>zTMdl_AniSample.position[1]</code> and <code>zTMdl_AniSample.position[2]</code> respectively. This operation is performed by <code>zTMdl_AniSample::UnpackTrans</code> .</p>"},{"location":"engine/formats/animation/#sample-rotations","title":"Sample Rotations","text":"<p>The rotations are represented as a packed quaternion which is calculated in the following way:</p> \\[     \\begin{bmatrix}         x_{p} \\\\         y_{p} \\\\         z_{p}     \\end{bmatrix}     =     \\begin{cases}         \\begin{bmatrix}             x \\\\             y \\\\             z         \\end{bmatrix}         \\div s + h  &amp; \\quad \\text{if } w \\geq 0 \\\\         -\\Bigg(         \\begin{bmatrix}             x \\\\             y \\\\             z         \\end{bmatrix}         \\div s + h\\Bigg) - 2  &amp; \\quad \\text{if } w &lt; 0 \\\\     \\end{cases} \\] <p>where</p> \\[     s = \\frac{1}{2^{16} - 1} * 2.1 = \\frac{1}{65535} * 2.1 \\] <p>and</p> \\[     h = 2^{15} - 1 = 32767 \\] <p>This operation packs a quaternion of the form \\(r = \\begin{smallmatrix}x \\\\ y \\\\ z \\\\ w\\end{smallmatrix}\\) into a set of three 16-bit unsigned integers \\(x_{p}\\) , \\(y_{p}\\) and \\(z_{p}\\) which are stored into the sample. The input quaternion \\(r\\) is required to be a unit vector. This operation was performed by <code>zCModelAni::AddTrafoMatrix</code> and <code>zTMdl_AniSample::PackQuat</code>.</p> <p>They can be unpacked using some quaternion wizardry as described below.</p> \\[     \\begin{bmatrix}         x \\\\         y \\\\         z \\\\         w      \\end{bmatrix}     =     \\begin{cases}         \\begin{bmatrix}             x_{t} \\\\             y_{t} \\\\             z_{t} \\\\             \\sqrt{1 - l}         \\end{bmatrix} &amp; \\quad \\text{if } l \\leq 1 \\\\         \\begin{bmatrix}             x_{t} \\\\             y_{t} \\\\             z_{t} \\\\             0         \\end{bmatrix}         \\cdot \\frac{1}{\\sqrt{l}} &amp; \\quad \\text{if } l &gt; 1     \\end{cases}  \\] <p>where</p> \\[     \\begin{bmatrix}         x_{t} \\\\         y_{t} \\\\         z_{t} \\\\     \\end{bmatrix}     =     \\Bigg(\\begin{bmatrix}         x_{p} \\\\         y_{p} \\\\         z_{p} \\\\     \\end{bmatrix} - h\\Bigg) \\cdot s \\] <p>and</p> \\[     l = (x_{t})^2 + (y_{t})^2 + (z_{t})^2 \\] <p>The values \\(x_{p}\\) , \\(y_{p}\\) and \\(z_{p}\\) for this computation are stored in <code>zTMdl_AniSample.rotation[0]</code>, <code>zTMdl_AniSample.rotation[1]</code> and <code>zTMdl_AniSample.rotation[2]</code> respectively. This is possible since the quaternion \\(r\\) used to calculate the packed rotation is guaranteed to be a unit-quaternion, thus, if we have three components (like we do), it is possible to calculate the third component. This operation is performed by <code>zTMdl_AniSample::UnpackQuat</code>.</p>"},{"location":"engine/formats/animation/#todo-how-animated-models-are-loaded","title":"(todo) How animated models are loaded","text":"<p>Animated models are loaded by using their associated model script file. While parsing the model script, the parser will encounter a <code>meshAndTree</code> directive (in MSB files a chunk of type <code>0xf300</code>) which points to a model hierarchy.</p> <p>This model hierarchy is then loaded and acts as the ground truth of the model. If a hierarchy can't be loaded for any reason, the engine tries to load a model mesh instead.</p> <p>The model script parser continues and eventually hits the <code>aniEnum</code> section. While loading it, it will come across <code>ani</code> sections. Those sections contain a model and animation name which are then loaded as animations and model meshes respectively.</p> <p>Linking these parts together is a checksum calculates from the list of hierarchy nodes. It is just the CRC32 checksum of all node names appended after each other in the order they are saved in. I.e. a model hierarchy with two nodes <code>\"BIP01\"</code> and <code>\"BIP01 LEVER STICK\"</code> (in that order) will have a checksum of <code>ea809bf7</code> (which is <code>crc32(\"BIP01BIP01 LEVER STICK\")</code>.</p>"},{"location":"engine/formats/archive/","title":"ZenGin Archives","text":"<p>ZenGin archives (ZEN files) contain generic data for use with the ZenGin. Most archives store key-value pairs organized into objects, similar to JSON. Archives have three different encodings: binary archives store unannotated bytes, safe binary archives store binary data annotated with field types and names and ascii archives contain a human-readable form of the same data stored in safe binary archives.</p>"},{"location":"engine/formats/archive/#general-concepts","title":"General Concepts","text":"<p>A basic archive file might look like this.</p> Example ZEN archive (ASCII)<pre><code>ZenGin Archive\nver 1\nzCArchiverGeneric\nASCII\nsaveGame 0\ndate 17.9.2002 15:21:1\nuser mario.roeske\nEND\nobjects 7        \nEND\n[% oCWorld:zCWorld 64513 0]\n    [VobTree % 0 0]\n        childs0=int:1\n        [% zCVob 39168 1]\n            pack=int:0\n            presetName=string:LIGHT\n            bbox3DWS=rawFloat:334.003906 -443.912476 -7493.55371 2734.00391 1956.08765 -5093.55371 \n            trafoOSToWSRot=raw:974226bf00000000a9a9423f000000000000803f00000000a9a942bf00000000974226bf\n            trafoOSToWSPos=vec3:1534.00403 756.087585 -6293.55371\n            vobName=string:LIGHT\n            visual=string:\n            showVisual=bool:0\n            visualCamAlign=enum:0\n            visualAniMode=enum:0\n            visualAniModeStrength=float:0\n            vobFarClipZScale=float:1\n            cdStatic=bool:0\n            cdDyn=bool:0\n            staticVob=bool:1\n            dynShadow=enum:0\n            zbias=int:1\n            isAmbient=bool:0\n            [visual % 0 0]\n            []\n            [ai % 0 0]\n            []\n        []\n    []\n[]\n</code></pre> <p>At the beginning of the file, the header is defined. It consists of two parts, the first one being the same across all encoding and the second being specific to the encoding used. The data content of the file starts right after the second <code>END</code>. The first line of the file's content, <code>[% oCWorld:zCWorld 64513 0]</code>, marks the start of a new object while the last line, <code>[]</code> marks the end of an object.</p> <p>Each object can contain multiple entries alongside other objects. Each entry has a name, a type and a value. This only applies to ascii and safe binary encodings.</p>"},{"location":"engine/formats/archive/#header","title":"Header","text":"<p>The header of ZEN archives consists of two parts. The first has the same structure for every archive and the second differs between encodings. The first part of the header looks like this. Variable elements of the header have been replaced by <code>&lt;...&gt;</code> placeholders.</p> Example ZEN archive header<pre><code>ZenGin Archive\nver 1\n&lt;archiver&gt;\n&lt;encoding&gt;\nsaveGame &lt;issave&gt;\ndate &lt;timestamp&gt;\nuser &lt;username&gt;\nEND\n</code></pre> <p>Line breaks denote only one newline (<code>\\n</code>) character. The <code>&lt;archiver&gt;</code> is a string value, being either <code>zCArchiverGeneric</code> or <code>zCArchiverBinSafe</code>, in reference to the names of the ZEN archive parser classes in the original source code. <code>&lt;encoding&gt;</code> specifies the type of archive in the file. It is either <code>ASCII</code> (for ascii encoded archives), <code>BINARY</code> (for binary encoded archives) or <code>BIN_SAFE</code> (for safe binary encoded archives). If the archive is a save game file <code>&lt;issave&gt;</code> is set to <code>1</code>, otherwise it is <code>0</code>. <code>&lt;timestamp&gt;</code> denotes the date and time the archive was created. It follows the strptime format <code>%d.%m.%Y %H:%M:%S</code>. <code>&lt;username&gt;</code> is the name of the user (originally the windows account name) the archive was created by. For save games this contains the name of the user who saved the game. Refer to the example above for a filled-out version of the header.</p> <p>The encoding-specific headers follow directly after the <code>END\\n</code> line of the first header as can be seen in the example.</p>"},{"location":"engine/formats/archive/#objects","title":"Objects","text":"<p>Objects in ZEN archives consist of an object name, a class name, a version identifier and an index. The object name is used to describe a unique sub-object of another while the class name is used to identify the type of the object. A ZEN archive object <code>[visual zCParticleFX 0 6]</code> describes a specific sub-object <code>visual</code> of type <code>zCParticleFX</code> meaning it has a set of entries consistent with the definition of a <code>zCParticleFX</code>. Objects without an object name just contain a <code>%</code> instead. Objects always end with <code>[]</code>.</p> <p>Note</p> <p>This behavior can be seen in the example above. Every object with the class name <code>zCVob</code> has the same set of entries as shown in the example.</p> <p>Danger</p> <p>The object name must be unique within each sub-object. A ZEN archive like this is invalid.</p> Text Only<pre><code>[% oCWorld:zCWorld 64513 0]\n    [VobTree % 0 0]\n    []\n    [VobTree % 0 0]\n    []\n[]\n</code></pre> <p>Class names originally referenced a specific class in C++-code. These classes were polymorphic so an object with a class name <code>zCVobLight:zCVob</code> contains both entries of type <code>zCVob</code> and <code>zCVobLight</code>. The entries of the super-class always precede the entries of the subclass, so the <code>zCVobLight:zCVob</code> would first contain all entries of <code>zCVob</code> and then all entries of <code>zCVobLight</code>. Objects without a class name just contain a <code>%</code> instead.</p> <p>Warning</p> <p>Class and object names may not contain spaces.</p> <p>The version of an object is a 32-bit unsigned number which denotes the version of the bottom-most subclass. The version of object <code>[% oCMobInter:oCMOB:zCVob 35585 0]</code> would be <code>35585</code>. This version, however, only refers to the <code>oCMobInter</code>-part.</p> <p>Danger</p> <p>This leads to issues when trying to determine whether an object uses the Gothic or the Gothic II definition. If the structure for <code>oCMobInter</code> did not change between the games, the version will be the same. This is not necessarily true for <code>zVob</code> though. Its definition might have changed but this change is not reflected in the <code>version</code> field of the object.</p> <p>The index field of the object is a 32-bit unsigned number which increments for every object with a class name in the archive. In the example this can be seen with the objects <code>[% oCWorld:zCWorld 64513 0]</code> and <code>[% zCVob 39168 1]</code>. Objects without a class name have an index of <code>0</code>.</p>"},{"location":"engine/formats/archive/#entries","title":"Entries","text":"<p>The concept of entries only really applies to archives with ascii or safe binary encoding. An entry originally represented a field in a C++-class which defined an object. For this reason, each entry has a name, a type and a value. The following entry types are supported:</p> Type Name Type ID1 Description <code>string</code> 1 ISO-8859-1 encoded text <code>int</code> 2 A 32-bit signed integer <code>float</code> 3 An IEEE 754 floating-point number <code>byte</code> 4 An 8-bit unsigned integer <code>word</code> 5 An 16-bit unsigned integer <code>bool</code> 6 An boolean value2 <code>vec3</code> 7 A set of 3 IEEE 754 floating-point numbers <code>color</code> 8 A set of 4 8-bit unsigned integers <code>raw</code> 9 A set of an arbitrary amount of 8-bit unsigned integers <code>rawFloat</code> 16 A set of an arbitrary amount of IEEE 754 floating-point numbers <code>enum</code> 17 A 32-bit unsigned integer3 <code>hash</code> 18 A 32-bit unsigned integer; specific to the safe binary encoding"},{"location":"engine/formats/archive/#ascii","title":"ASCII","text":"<p>ASCII-archives are human-readable ZEN archives, comparable to JSON. Contrary to its name, the file is not actually using the ASCII text encoding. Rather these files are encoded in ISO-8859-1 or alternatively Windows-1252 (because the characters used are encoded identically).</p> <p>ASCII ZEN-archives use a line-based format. Every line after the header contains exactly one object start statement, entry statement or object end token. Leading whitespace is ignored.</p>"},{"location":"engine/formats/archive/#header_1","title":"Header","text":"<p>The encoding specific header for the ASCII-encoding looks like this. Variable elements of the header have been replaced by <code>&lt;...&gt;</code> placeholders.</p> Text Only<pre><code>objects &lt;count&gt;\nEND\n</code></pre> <p><code>&lt;count&gt;</code> denotes the total number of objects in the archive. Refer to the example above for a filled-out version of the header.</p>"},{"location":"engine/formats/archive/#objects_1","title":"Objects","text":"<p>As stated above, objects in ASCII-ZENs start with a line <code>[% oCWorld:zCWorld 64513 0]</code> defined as <code>[&lt;object name&gt; &lt;class name&gt; &lt;version&gt; &lt;index&gt;]</code>. This is explained further in the section about objects.</p>"},{"location":"engine/formats/archive/#entries_1","title":"Entries","text":"<p>Entries in ASCII-ZENs follow the format <code>&lt;name&gt;:&lt;type&gt;=&lt;value&gt;</code> where <code>&lt;name&gt;</code> is a C++ identifier, <code>&lt;type&gt;</code> is one of the type names mentioned in the entries section with the exclusion of the <code>hash</code> type. <code>&lt;value&gt;</code> depends on the given type. It has the following formats:</p> Type Name Format Regex Example <code>string</code> An unlimited number of characters excluding newline characters <code>^[^\\n\\r]*</code> <code>field=string:This is a string</code> <code>int</code> A decimal 32-bit integer <code>^[+-]?\\d+$</code> <code>field=int:199</code> <code>float</code> A decimal floating point value with decimal separator <code>.</code> <code>^[+-]?(\\d+\\.)?\\d+$</code> <code>field=float:-1.0</code> <code>byte</code> A decimal 8-bit unsigned integer <code>^\\d{1,3}$</code> <code>field=byte:255</code> <code>word</code> A decimal 16-bit unsigned integer <code>^\\d+$</code> <code>field=word:1001</code> <code>bool</code> A decimal 1-bit integer <code>^[01]$</code> <code>field=bool:1</code> <code>vec3</code> A set of three floating point values <code>^[+-]?(\\d+\\.)?\\d+ [+-]?(\\d+\\.)?\\d+ [+-]?(\\d+\\.)?\\d+$</code> <code>field=vec3:1.0 -0.1 +100</code> <code>color</code> A set of four 8-bit unsigned integers <code>^\\d{1,3} \\d{1,3} \\d{1,3} \\d{1,3}$</code> <code>field=color:100 0 255 12</code> <code>raw</code> An unlimited number of hexadecimal bytes <code>^([0-9A-Fa-f]{2})*</code> <code>field=raw:0fac3256b1</code> <code>rawFloat</code> An unlimited number of floating point values <code>^([+-]?(\\d+\\.)?\\d+ )*</code> <code>field=rawFloat:1.0 -100</code> <code>enum</code> A decimal 32-bit unsigned integer <code>^\\d+$</code> <code>field=enum:10</code>"},{"location":"engine/formats/archive/#binary","title":"Binary","text":"<p>Binary archives are little more than containers for raw bytes. They don't actually contain key-value pairs.</p>"},{"location":"engine/formats/archive/#header_2","title":"Header","text":"<p>The encoding specific header for the Binary-encoding is the same as that of the ascii encoding. Variable elements of the header have been replaced by <code>&lt;...&gt;</code> placeholders.</p> Text Only<pre><code>objects &lt;count&gt;\nEND\n</code></pre> <p><code>&lt;count&gt;</code> denotes the total number of objects in the archive.</p>"},{"location":"engine/formats/archive/#objects_2","title":"Objects","text":"<p>Objects in binary ZENs don't work like they do in the ascii and safe binary encodings. No object end marker is stored and the beginning of an object does not follow the same format.</p> Binary archive object begin structure<pre><code>#pragma pack(push, 1)\nstruct zen_object_begin {\nuint32_t object_size; //the size of the object in bytes, including the header.\nuint16_t version; // the *version* number of the object\nuint32_t index; // the *index* of the object\nchar* object_name; // The *name* of the object including a null-termination character\nchar* class_name; // The *class* of the object including a null-termination character\n};\n#pragma pack(pop)\n</code></pre>"},{"location":"engine/formats/archive/#entries_2","title":"Entries","text":"<p>Binary ZENs just contains packed bytes with no added type annotations. This makes it very difficult to determine the layout of structures within it without having access to the original source code.</p> <p>To read an integer from a binary ZEN for example, the next four bytes are read in literally like this (assuming a little-endian architecture).</p> Binary archive entry read scalar example<pre><code>int32_t zen_binary_read_int(FILE* fp) {\nint32_t value = 0;\nfread(&amp;value, sizeof(value), 1, fp);\nreturn value;\n}\n</code></pre> <p>Note</p> <p>On big-endian architectures, the value read would have to be byte-swapped after reading.</p> <p>This method of extracting values from binary archives is also used for aggregate types, like the <code>vec3</code>. Instead of reading just one float from the input, three are read like this.</p> Binary ZEN entry read vector example<pre><code>typedef struct vec3 {\nfloat x;\nfloat y;\nfloat z;\n} vec3_t;\nvec3_t zen_binary_read_int(FILE* fp) {\nvec3_t value;\nfread(&amp;value.x, sizeof(float), 1, fp);\nfread(&amp;value.y, sizeof(float), 1, fp);\nfread(&amp;value.z, sizeof(float), 1, fp);\nreturn value;\n}\n</code></pre> <p>Refer to the following table for type sizes.</p> Type Name C-equivalent Byte Count <code>string</code> <code>char[]</code> <code>1 * n</code> <code>int</code> <code>int32_t</code> 4 <code>float</code> <code>float</code> 4 <code>byte</code> <code>uint8_t</code> 1 <code>word</code> <code>uint16_t</code> 2 <code>bool</code> <code>uint8_t</code> 1 <code>vec3</code> <code>struct { float, float, float }</code> <code>4 * 3</code> <code>color</code> <code>struct { uint8_t, uint8_t, uint8_t, uint8_t }</code> <code>1 * 4</code> <code>raw</code> <code>uint8_t[]</code> <code>1 * n</code> <code>rawFloat</code> <code>float[]</code> <code>4 * n</code> <code>enum</code> <code>uint32_t</code> 4"},{"location":"engine/formats/archive/#safe-binary","title":"Safe Binary","text":"<p>Safe binary archives store binary values annotated with field types and names. They are the most prevalent types of archives and also the ones in which world data is stored. The values of entries as well as their prefixes are stored in a packed binary format. This encoding is not fully reverse-engineered.</p>"},{"location":"engine/formats/archive/#header_3","title":"Header","text":"<p>The header of safe binary archives is also binary and has the following structure.</p> Safe binary archive header structure<pre><code>#pragma pack(push, 1)\nstruct zen_binsafe_header {\nuint32_t bs_version; // A separate version identifier for the version of the safe binary encoding used.\nuint32_t object_count; // The total number of objects in the archive\nuint32_t hash_table_offset; // The offset of the hash table from the beginning of the file in bytes; discussed below.\n};\n#pragma pack(pop)\n</code></pre> <p>In addition to the secondary header, safe binary archives also contain a so-called hash table4 which stores field name information. The hash table is a binary structure as well; it looks like this.</p> Safe binary ZEN hash table structure<pre><code>#pragma pack(push, 1)\nstruct zen_binsafe_hashtable_entry {\nuint16_t name_length; // The length of the name string at the end of the structure\nuint16_t insertion_index; // The index of this entry in the hashtable `entries` member array\nuint32_t hash_value; // The hash value of the entry. Its purpose is currently unknown.\nchar name[]; // The name of the entry. This name is the field name of the entry as explained below\n};\nstruct zen_binsafe_hashtable {\nuint32_t size; // The number of entries in the hash table. Corresponds with the length of the `entries` member array.\nzen_binsafe_hashtable_entry entries[]; // An array of all hash table entries; unordered.\n};\n#pragma pack(pop)\n</code></pre>"},{"location":"engine/formats/archive/#objects_3","title":"Objects","text":"<p>In safe binary ZENs, objects are handled in almost the same way entries are. Objects definitions are preceded by the string type identifier <code>\\x01</code> and a 16-bit string length value. The value of this string is the same as the object definition for ASCII-ZENs: Objects start with a line <code>[% oCWorld:zCWorld 64513 0]</code> defined as <code>[&lt;object name&gt; &lt;class name&gt; &lt;version&gt; &lt;index&gt;]</code>. This is explained further in the section about objects.</p> <p>A full object definition might look like this: <code>\\x01\\x1B\\x00[% oCWorld:zCWorld 64513 0]</code>.</p> <p>Note</p> <p>Note that objects are never preceded by a field name like entries are.</p>"},{"location":"engine/formats/archive/#entries_3","title":"Entries","text":"<p>Every entry in safe binary ZENs is preceded by a field name index and a type identifier including a length if applicable. File name indexes start with a <code>\\x12</code> which is followed by a 32-bit unsigned integer, indicating an index into the hash table discussed above. The name of the hash table entry at that index is the name of the field.</p> <p>A boolean entry in this format might look like <code>\\x12\\x01\\x00\\00\\x00\\x06\\x01\\x00\\x00\\x00</code>. It hashtable index is <code>1</code> and its value is <code>true</code>. Type IDs are always <code>uint8_t</code>s and hashtable indices are always <code>uint32_t</code>s.</p> <p>Reference the table below for all types in safe binary archives.</p> Type Name Type ID Has Length? C-equivalent Byte Count <code>string</code> 1 Yes <code>char[]</code> <code>1 * n</code> <code>int</code> 2 No <code>int32_t</code> 4 <code>float</code> 3 No <code>float</code> 4 <code>byte</code> 4 No <code>uint8_t</code> 1 <code>word</code> 5 No <code>uint16_t</code> 2 <code>bool</code> 6 No <code>uint32_t</code> 4 <code>vec3</code> 7 No <code>struct { float, float, float }</code> <code>4 * 3</code> <code>color</code> 8 No <code>struct { uint8_t, uint8_t, uint8_t, uint8_t }</code> <code>1 * 4</code> <code>raw</code> 9 Yes <code>uint8_t[]</code> <code>1 * n</code> <code>rawFloat</code> 16 Yes <code>float[]</code> <code>4 * n</code> <code>enum</code> 17 No <code>uint32_t</code> 4 <p>Note</p> <p>Entries with a length prefix, are encoded like this: <code>\\x12\\x01\\x00\\00\\x00\\x01\\x0D\\x00Hello, world!</code>. It hashtable index is <code>1</code>, its length is <code>0x0D</code> and its value is <code>Hello, World!</code>. Note that the length is always a <code>uint16_t</code> and always follows directly after the type ID.</p> <ol> <li> <p>The type index is relevant only for safe binary encoded archives.\u00a0\u21a9</p> </li> <li> <p>The actual representation of this value changes between encodings. With the safe binary encoding a boolean value is represented as a 32-bit unsigned integer while it is represented as an 8-bit integer in the binary encoding.\u00a0\u21a9</p> </li> <li> <p>Enums represent an actual enumeration value in C++-code.\u00a0\u21a9</p> </li> <li> <p>The origin of that name is unknown. It has been used in ZenLib to describe this element of the format.\u00a0\u21a9</p> </li> </ol>"},{"location":"engine/formats/font/","title":"ZenGin Fonts","text":"<p>Quick Infos</p> <p>Type: Asset Format Format Name: Font File Extension: <code>.FNT</code> Class Name: <code>zCFont</code> Encoding: Binary</p> <p>ZenGin font files contain metadata for bitmap fonts used in the engine. In particular, they contain the position and size of font glyphs in a texture file.</p> <p>Fonts are found within the <code>Textures.vdf</code> file found in the <code>Data/</code> directory in the Gothic installation.</p>"},{"location":"engine/formats/font/#format-description","title":"Format Description","text":"<p>Fonts are stored in a binary file which contains the following data. Also refer to the Datatype Reference for general information about often used datatypes.</p> Font Structure<pre><code>struct zCFont {\nstring version; // Always \"1\".\nstring imageName;\nuint glyphHeight;\nuint glyphCount; byte glyphWidths[/* glyphCount */];\nzVEC2 glyphTopLeftUVs[/* glyphCount */];\nzVEC2 glyphBottomRightUVs[/* glyphCount */];\n};\n</code></pre> <p>Since ZenGin fonts are a kind of bitmap font, a font texture is required in addition to this font metadata file. The name of that texture is found in <code>imageName</code>.</p> <p>To get the actual pixel coordinates for each glyph in the texture for any given UV-coordinate, multiply the <code>x</code> coordinate by the width of the texture and the <code>y</code> coordinate by the height of the texture.</p> <p>Warning</p> <p>Some coordinates are negative. These should be ignored since they don't have a glyph image associated with them.</p>"},{"location":"engine/formats/texture/","title":"ZenGin Textures","text":"<p>Quick Infos</p> <p>Type: Asset Format Format Name: Texture File Extension: <code>.TEX</code> Class Name: <code>zCTexture</code> Encoding: Binary Used By: <code>zCFont</code></p> <p>ZenGin texture files contain DXT1-5, palette or raw textures alongside mipmaps of each texture. Textures are contained within binary files which start with a header followed by palette and image data.</p> <p>Standalone textures are found within the <code>Textures.vdf</code> file found in the <code>Data/</code> directory in the Gothic installation. They are sometimes embedded into other formats too, though.</p>"},{"location":"engine/formats/texture/#format-description","title":"Format Description","text":"<p>Textures are stored in a binary file which contains the following data. Also refer to the Datatype Reference for general information about often used datatypes.</p> Texture Structure<pre><code>enum zCTexture_Format {\nbgra8  = (uint32_t) 0, // 32-bit BGRA pixel format with alpha, using 8 bits per channel\nrgba8  = (uint32_t) 1, // 32-bit RGBA pixel format with alpha, using 8 bits per channel\nabgr8  = (uint32_t) 2, // 32-bit ABGR pixel format with alpha, using 8 bits per channel\nargb8  = (uint32_t) 3, // 32-bit ARGB pixel format with alpha, using 8 bits per channel\nbgr8   = (uint32_t) 4, // 24-bit BGR pixel format with 8 bits per channel\nrgb8   = (uint32_t) 5, // 24-bit RGB pixel format with 8 bits per channel\nargb4  = (uint32_t) 6, // 16-bit ARGB pixel format with 4 bits for each channel\na1rgb5 = (uint32_t) 7, // 16-bit ARGB pixel format where 5 bits are reserved for each color and 1 bit is reserved for alpha\nr5g6b5 = (uint32_t) 8, // 16-bit RGB pixel format with 5 bits for red, 6 bits for green, and 5 bits for blue\np8     = (uint32_t) 9, // 8-bit color indexed\ndxt1   = (uint32_t) 10, // DXT1 compression texture format\ndxt2   = (uint32_t) 11, // DXT2 compression texture format\ndxt3   = (uint32_t) 12, // DXT3 compression texture format\ndxt4   = (uint32_t) 13, // DXT4 compression texture format\ndxt5   = (uint32_t) 14, // DXT5 compression texture format\n};\nstruct zCTexture {\nchar magic[4]; // Always `\"ZTEX\"`.\nuint version; // Always 0.\nuint format; // One of enum zCTexture_Format\nuint width; // The width of the texture in pixels.\nuint height; // The height of the texture in pixels.\nuint numMipmaps; // The number of mipmap stored.\nuint referenceWidth;\nuint referenceHeight;\nuint averageColor; // A 32-bit ARGB value containing the average color of the image.\n// Texture data. See below for more information.\nunion {\nstruct {\nuint palette[256];\nbyte palettePixels[/* (width * height) */];\n};\nbyte rawPixels[/* (width * height * pixelsize(format) */]; // Depends on the pixel format (see zCTexture_Format)\n} mipmaps[/* numMipmaps */];\n};\n</code></pre> <p>Note</p> <p>All color values should be understood as word-order, so an <code>RGBA</code> color <code>#aabbccdd</code> would be represented as the bytes <code>dd cc bb aa</code> in little-endian byte order. An alpha byte of <code>0xff</code> means full opacity.</p>"},{"location":"engine/formats/texture/#mipmaps","title":"Mipmaps","text":"<p>Mipmaps are stored from the smallest to the largest image. If the mipmap-image with the level <code>0</code> has a with of <code>w</code> and a height of <code>h</code> pixels then the mipmap image with the level <code>n</code> has a width of <code>w &gt;&gt; n</code> and a height of <code>h &gt;&gt; n</code> pixels (each mipmap-level is half the size of the previous one).</p>"},{"location":"engine/formats/texture/#format-dxt","title":"Format: DXT","text":"<p>If the texture format is <code>dxt1</code>, <code>dxt2</code>, <code>dxt3</code>, <code>dxt4</code> or <code>dxt5</code> the data stored right after the header is DXT compressed. To figure out the size of each mipmap-level in bytes, for DXT1 compressed data calculate <code>max(1, w / 4) * max(1, h / 4) * 8</code>1 and for DXT2-DXT5 calculate <code>max(1, w / 4) * max(1, h / 4) * 16</code>1 where <code>w</code> and <code>h</code> depend on the mipmap level. In practice, only DXT1, DXT3 AND DXT5 are used.</p>"},{"location":"engine/formats/texture/#format-palette","title":"Format: Palette","text":"<p>With the <code>p8</code> format, the texture file contains a palette-list before the actual texture data. This palette follows right after the header and contains <code>256</code> 32-bit ARGB8 colors. These are then referenced in the texture data section right after the palette data. Each byte in the texture data represents one pixel. Its color is the color in the palette at the index indicated by the byte's value.</p>"},{"location":"engine/formats/texture/#format-raw","title":"Format: Raw","text":"<p>If the format is not <code>p8</code> and not one of the <code>dxt</code> formats, the texture stores raw data according to the format described above. For <code>bgra8</code>, <code>rgba8</code>, <code>abgr8</code> and <code>argb8</code> formats, each pixel is 4 bytes in size. With formats <code>bgr8</code> and <code>rgb8</code>, each pixel is 3 bytes in size. <code>argb4</code>, <code>a1rgb5</code> and <code>r5g6b5</code> contain 2-byte sized pixels.</p> <ol> <li> <p>This calculation has been adopted from ZenLib.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"engine/formats/vdf/","title":"ZenGin Virtual File System","text":"<p>Quick Infos</p> <p>Type: Asset Format Format Name: Virtual File System File Extension: <code>.VDF</code> Class Name: <code>zFILE_VDFS</code> 3 Encoding: Binary</p> <p>VDF is a container format for a file/directory structure, similar to the tar format. VDF files are not intended to be used for general file transfer, and thus they don't contain metadata like permission information which can usually be found in such container formats.</p> <p>VDF files can usually be found in the <code>Data/</code> directory of Gothic installations.</p>"},{"location":"engine/formats/vdf/#format-description","title":"Format Description","text":"<p>VDF files consist of a header, the catalog and a data section which are described below. Also refer to the Datatype Reference for general information about often used datatypes.</p> VDF Structure<pre><code>struct zFILE_VDFS {\nzFILE_VDFS_Header header;\nzFILE_VDFS_Catalog catalog;\nbyte data[];\n};\n</code></pre>"},{"location":"engine/formats/vdf/#header","title":"Header","text":"<p>The VDFs header describes the file and its contents. It always has the same physical size and can be represented as a C struct like this.</p> VDF Header<pre><code>struct zFILE_VDFS_Header {\nchar comment[256]; // (1)\nchar signature[16]; // (2)\nuint numFiles;\nuint numEntries;\nuint timestamp; // (3)\nuint size; // (4)\nuint catalogOffset; // (5)\nuint version; // (6)\n};\n</code></pre> <ol> <li>The comment might not fill the entire 256 bytes. If it does not, the rest of the array is filled with <code>'\\x1A'</code>    characters.</li> <li>The signature indicates which game this VDF file was made for. If it is <code>\"PSVDSC_V2.00\\r\\n\\r\\n\"</code> then the VDF was    made for Gothic and if it is <code>\"PSVDSC_V2.00\\n\\r\\n\\r\"</code> it was made for Gothic II.</li> <li>The timestamp has a special format called \"DOS date format\" by all sources1. It is described    below.</li> <li>The full size of the file in bytes.</li> <li>An offset from the beginning of the file in bytes at which the first entry of the catalog is located.</li> <li>The version of the VDF format being used. This is always <code>0x50</code> in reality.</li> </ol>"},{"location":"engine/formats/vdf/#catalog","title":"Catalog","text":"<p>The catalog describes the directory and file structure contained within the VDF file. Each entry is either a file or a directory entry. File entries always point to an address in the data section of the container while directory entries always point to a subsection of the catalog listing the child entries of the directory. Here's a basic example:</p> Text Only<pre><code>00 _WORK/  -&gt; 01\n01   DATA/    -&gt; 03\n02   CUSTOM/  -&gt; 10\n03     ANIMS/     -&gt; 05\n04     TEXTURES/  -&gt; 07\n05       ANIM1.MAN\n06       ANIM2.MAN\n07       TEXTURE_A.TEX\n08       TEXTURE_B.TEX\n09       TEXTURE_C.TEX\n10     MYFILE.WAV\n</code></pre> <p>As you can see, the full path of <code>ANIM1.MAN</code> would be <code>_WORK/DATA/ANIMS/ANIM1.MAN</code>. Notice that all entries of a directory are always listed right after each other, and their respective child entries are listed after the parent folder's entries.</p> <p>Each entry can be represented as a C struct like this.</p> VDF Catalog<pre><code>struct zFILE_VDFS_Catalog {\nstruct {\nchar name[64]; // (1)\nuint32_t offset; // (2)\nuint32_t size; // (3)\nuint32_t type; // (4)\nuint32_t attributes; // (5)\n} entries[/* zFILE_VDFS_Header.numEntries */];\n};\n</code></pre> <ol> <li>The name might not fill the entire 64 bytes. If it does not, the rest of the array is filled with <code>'\\x20'</code>    characters.</li> <li>If the entry is a file, this contains an offset into the file at which the entry's data is stored.    If it is a directory, this contains the index of the first child entry in the catalog.</li> <li>The size of the entry if it is a file, otherwise contains 0.</li> <li>A bitmask describing the type of the entry. If bit <code>0x80000000</code> is set, the entry is a directory, otherwise it is    a file. If bit <code>0x40000000</code> is set, the entry is the last in the parent directory2.</li> <li>Extra attributes for the entry. Unused.</li> </ol>"},{"location":"engine/formats/vdf/#dos-date-format","title":"DOS date format","text":"<p>The timestamp format used for VDF files has been called DOS date format1, however I can not find any official reference for it online. In any case, these timestamps are saved in a 32-bit unsigned integer and formatted like this.</p> DOS date format<pre><code>//                            year (1)       day         minute\n//                            ---------      -----       ------\nuint32_t date = 0x2D65BBB3 == 0b0010110'1011'00101'10111'011101'10011\n//                                      ----       -----        -----\n//                                     month (2)    hour       second (3)\n</code></pre> <ol> <li>The number of years after 1980, here <code>1980 + 0b0010110 = 2002</code></li> <li>The month starts counting a <code>1</code> (January), here <code>11 = November</code></li> <li>Seconds are only stored with half-precision so to get the correct number, the number has to be multiplied by two,    here <code>0b10011 * 2 = 38</code></li> </ol> <p>This reference implementation can be used to load and create DOS timestamps. It is heavily based on the implementation in PhysicsFS.</p> DOS date format reference implementation<pre><code>/**\n * Converts a DOS timestamp to a standard unix timestamp.\n */\ntime_t dos_to_unix_time(uint32_t dos) {\nstruct tm t {};\nt.tm_year = ((int) ((dos &gt;&gt; 25) &amp; 0x7F)) + 80;\nt.tm_mon =  ((int) ((dos &gt;&gt; 21) &amp; 0x0F)) - 1;\nt.tm_mday =  (int) ((dos &gt;&gt; 16) &amp; 0x1F);\nt.tm_hour =  (int) ((dos &gt;&gt; 11) &amp; 0x1F);\nt.tm_min =   (int) ((dos &gt;&gt; 5 ) &amp; 0x3F);\nt.tm_sec =  ((int) ((dos &gt;&gt; 0 ) &amp; 0x1F)) * 2;\nreturn timegm(&amp;t);\n}\n/**\n * Converts a unix timestamp to a DOS timestamp.\n */\nuint32_t unix_time_to_dos(time_t nix) {\nstruct tm* t {gmtime(&amp;nix)};\nuint32_t dos {0};\ndos |= (t-&gt;tm_year - 80) &lt;&lt; 25;\ndos |= (t-&gt;tm_mon + 1) &lt;&lt; 21;\ndos |= t-&gt;tm_mday &lt;&lt; 16;\ndos |= t-&gt;tm_hour &lt;&lt; 11;\ndos |= t-&gt;tm_min &lt;&lt; 5;\ndos |= (t-&gt;tm_sec / 2) &lt;&lt; 0;\nreturn dos;\n}\n</code></pre> <ol> <li> <p>References to the DOS date format can be found in PhysicsFS where the VDF format is implemented. It is also discussed in the Wiki for ReGoth (the old repository).\u00a0\u21a9\u21a9</p> </li> <li> <p>Referring back to the example, the <code>0x40000000</code> bit will be set for entries <code>_WORK/</code> (<code>00</code>), <code>CUSTOM/</code> (<code>02</code>), <code>TEXTURES/</code> (<code>04</code>), <code>ANIM2.MAN</code> (<code>06</code>), <code>TEXTURE_C.TEX</code> (<code>09</code>) and <code>MYFILE.WAV</code> (<code>10</code>).\u00a0\u21a9</p> </li> <li> <p>It should be noted that the original implementation of VDF files was provided by a separate DLL called <code>Vdfs32g.dll</code>. <code>zFILE_VDFS</code> is merely an implementation using that API.\u00a0\u21a9</p> </li> </ol>"},{"location":"library/overview/","title":"Library Reference","text":"<p>Welcome to the phoenix reference documentation. This page contains information about how to use phoenix, a C++-library for parsing file formats used by the ZenGin, an early 2000's game engine developed by Piranha Bytes for the games Gothic and Gothic II.</p> <p>If you are new to phoenix, a good place to start is Getting Started. If you are looking for information about a specific file type, the File Type Reference might be the place you're looking for.</p>"},{"location":"library/quickstart/","title":"Getting Started","text":"<p>To get started using phoenix, you will first need to add it to your project as a library. This page will show you two ways of doing that but there are a lot more ways you can use. This page will also give you a brief overview of phoenix and provide a simple example. You can find a list of file types and information about loading them with phoenix in the File Type Reference.</p> <p>Feel free to ask any questions you might have over in the  Discussions section of the GitHub repository!</p>"},{"location":"library/quickstart/#adding-phoenix-to-your-project","title":"Adding phoenix to your project","text":"<p>phoenix uses the CMake build system which also is the easiest way of adding it to your project. There are two main ways of doing that</p> <ol> <li>Add phoenix as a Git submodule or</li> <li>Let CMake load it at configuration time.</li> </ol> <p>To add phoenix as a Git submodule, simply create a directory in your project to house submodules (common names are <code>vendor</code>, <code>3rdparty</code> or <code>lib</code>) and run the following commands:</p> Bash<pre><code># either this, to use the development version of phoenix\ngit submodule add https://github.com/lmichaelis/phoenix.git path-to-submodule-directory/phoenix\n\n# ... or this to use a phoenix release (recommended)\ngit submodule add -b v1.0 https://github.com/lmichaelis/phoenix.git path-to-submodule-directory/phoenix\n</code></pre> <p>After doing this, open your <code>CMakeLists.txt</code> file and add a line <code>add_subdirectory(path-to-submodule-directory/phoenix)</code> to it. You can now add <code>phoenix</code> to your <code>target_link_libraries(...)</code>. Make sure to also commit the new directory to your repository, otherwise it will only exist in your local file system.</p> <p>To add phoenix to your project without using Git submodules, add the following lines to your <code>CMakeLists.txt</code>.</p> CMake<pre><code>include(ExternalProject)\nfind_package(Git REQUIRED)\nExternalProject_Add(\nphoenix\nGIT_REPOSITORY https://github.com/lmichaelis/phoenix\nUPDATE_COMMAND ${GIT_EXECUTABLE} pull\nLOG_DOWNLOAD ON\n)\n</code></pre> <p>You can also do this without using Git by using CMake's FetchContent interface. Just point it to the URL of the source download of the  Release of phoenix you'd like to use. After doing either of these, you can add phoenix as a library by adding it to your <code>target_link_libraries(...)</code>.</p>"},{"location":"library/quickstart/#a-basic-example","title":"A basic example","text":"<p>This is a basic example of how to use phoenix. It opens a VDF File (<code>.VDF</code>) and reads a single entry from it. It then parses that entry as a Font and prints the name of the associated texture file to the terminal.</p> C++<pre><code>#include &lt;phoenix/vdfs.hh&gt;  // required to load VDF files\n#include &lt;phoenix/font.hh&gt;  // required to parse fonts\n#include &lt;iostream&gt;\nint main(int argc, const char** argv) {\nif (argc &lt; 2) {\nstd::cerr &lt;&lt; \"please provide a textures.vdf file to read from\\n\";\nreturn 1;\n}\n// Open the VDF file\nphoenix::vdf_file vdf = phoenix::vdf_file::open(argv[1]);\n// Find the font entry in the VDF\nconst phoenix::vdf_entry* font_file = vdf.find_entry(\"font_default.fnt\");\n// Make sure the entry actually exists\nif (font_file == nullptr) {\nstd::cerr &lt;&lt; \"FONT_DEFAULT.FNT was not found in the VDF\\n\";\nreturn 2;\n}\n// Open the file and parse a font from it\nphoenix::buffer font_data = font_file-&gt;open();\nphoenix::font font = phoenix::font::parse(font_data);\n// Print out the associated texture name\nstd::cout &lt;&lt; \"The associated texture for FONT_DEFAULT.FNT is \\\"\" &lt;&lt; font.name &lt;&lt; \"\\\"\\n\";\nreturn 0;\n}\n</code></pre> <p>To run this, compile it while linking against <code>phoenix</code> and execute the resulting binary in a terminal giving it the path to the <code>Data/textures.vdf</code> file in any Gothic or Gothic II installation like this:</p> Bash<pre><code>./a.out /path/to/gothic/Data/textures.VDF\n</code></pre> <p>The most important data structure in phoenix is the <code>buffer</code>. It encapsulates raw bytes and is used to read other primitive types from files. Basically every public parsing API in phoenix accepts a <code>buffer</code> as input. As you can see, in this case we get a buffer by <code>open()</code>-ing a VDF entry, but we can also obtain one by calling <code>buffer::mmap()</code>, <code>buffer::read()</code> or <code>buffer::of()</code>. The functionality of each is described in the respective C++ documentation strings.</p> <p>More examples can be found in the  examples/ directory of the project.</p>"},{"location":"library/reference/","title":"File Type Reference","text":"<p>The ZenGin uses a lot of custom file formats to store game data like meshes, animations and textures. Originally these custom formats for specifically made with Direct3D and later DirectX in mind and are thus sometimes confusing to understand or use some proprietary API developed by Microsoft at the time. One example of this is DirectMusic which is used for the in-game music.</p> <p>All files used by the ZenGin are binary files with the little-endian byte order or text files encoded with the Windows-1252 character set.</p>"},{"location":"library/reference/#1st-party-formats","title":"1st-party formats","text":"<p>The following is a list of file types and formats used by ZenGin.</p> Format Extension Description phoenix Class Name Model Animation <code>.MAN</code> Contains animations for a model <code>animation</code> Model Hierarchy <code>.MDH</code> Contains skeletal information for a model <code>model_hierarchy</code> Model Mesh <code>.MDM</code> Contains the mesh of a model <code>model_mesh</code> Model <code>.MDL</code> Contains a mesh and a hierarchy which make up a model <code>model</code> Morph Mesh Binary <code>.MMB</code> Contains a morph mesh with its mesh, skeleton and animation data <code>morph_mesh</code> Multi Resolution Mesh <code>.MRM</code> Contains a mesh with CLOD information <code>proto_mesh</code> Mesh <code>.MSH</code> Contains mesh vertices and vertex features like materials <code>mesh</code> Daedalus Script Binaries <code>.DAT</code> Contains a compiled Daedalus script <code>script</code> Texture <code>.TEX</code> Contains texture data in a variety of formats <code>texture</code> Font <code>.FNT</code> Contains font data <code>font</code> ZenGin Archive <code>.ZEN</code> Contains various structured data. Used mostly for world hierarchy data and object persistence. <code>archive</code> Text/Cutscenes <code>.BIN</code>, <code>.CSL</code>, <code>.DAT</code>, <code>.LSC</code> Contains text and cutscene data <code>messages</code> Model Script <code>.MDS</code>, <code>.MSB</code> Contains model animation script data and associated hierarchy and mesh information <code>model_script</code> Virtual Disk <code>.VDF</code> Contains a directory structure containing multiple files; similar to tar. <code>vdf_file</code>"},{"location":"library/reference/#3rd-party-formats","title":"3rd-party formats","text":"<p>The ZenGin uses the following 3rd-party file formats:</p> <ul> <li>DirectMusic for the soundtrack</li> <li>DXT1,   DXT3   and DXT5 for texture compression</li> <li>WAV for speech and sound effects</li> <li>TGA for uncompressed images</li> <li>Bink for cutscene videos</li> </ul> <p>For all of these, Open Source parsers are available, however some of them are no longer maintained. For DirectMusic there is libdmusic, for DXT decompression there is squish, stb can also decompress DXT-compressed files and can read in TGA files and ffmpeg can load Bink video.</p>"},{"location":"library/formats/animation/","title":"Animation","text":"<p>Animations (also called Model Animations) form part of the animations system of the ZenGin they contain only animation samples, i.e. the position and orientation of each bone of the skeleton they're applied to. While there is space for additional data within animation files, it is mostly empty.</p>"},{"location":"library/formats/animation/#overview","title":"Overview","text":"<p>phoenix' implementation of animations lives in <code>include/phoenix/animation.hh</code> and <code>source/animation.cc</code>. The most important part of an animation are its samples. They are stored in <code>animation::samples</code> after it has been parsed. Animation files themselves don't contain information about when to run animation or any other effects which should be applied during it. Those parts of the animation system are defined in Model Script files which should be loaded before animations. The <code>animation::events</code> field will always be empty for that reason.</p>"},{"location":"library/formats/animation/#loading-a-font","title":"Loading a Font","text":"<p>Like most data structures in phoenix, animations can be loaded using the <code>phoenix::animation::parse()</code> function. It takes a <code>phoenix::buffer</code> as a parameter and loads the animation from it.</p> Example<pre><code>#include &lt;phoenix/animation.hh&gt;\nint main(int, const char** argv) {\nauto anim_buffer = phoenix::buffer::mmap(\"A.man\");\n[[maybe_unused]] auto anim = phoenix::animation::parse(anim_buffer);\nreturn 0;\n}\n</code></pre>"},{"location":"library/formats/archive/","title":"ZenGin Archives","text":"<p>The ZenGin Archive format is similar in concept to JSON or XML in that it is used to serialize nested data into a file which can be read later. There are three different kinds of archives called <code>ASCII</code>, <code>BINARY</code> and <code>BIN_SAFE</code> but the way these work exactly does not matter when using phoenix.</p> <p>For detailed documentation on the inner workings of archives, see the ZenGin Reference.</p>"},{"location":"library/formats/archive/#overview","title":"Overview","text":"<p>Like JSON, archives store values using a key-value structure where every key-value pair belongs to an object. Objects can also be nested. Unlike JSON, archives do not have first-class support for arrays, instead choosing a special type and encoding scheme. The class which is responsible for loading ZenGin Archives is called <code>phoenix::archive_reader</code> and can be found in <code>phoenix/include/archive.hh</code>.</p>"},{"location":"library/formats/archive/#loading-an-archive","title":"Loading an archive","text":"<p>Unlike most data structures in phoenix, archives can be loaded using the <code>phoenix::archive_reader::open()</code> function. It takes a <code>phoenix::buffer</code> and uses it internally for loading values from the archive.</p> <p>Danger</p> <p>The buffer passed to <code>open</code> is currently contained in the <code>archive_reader</code> as a reference. Trying to read from an <code>archive_reader</code> after the buffer passed in <code>open</code> has been destroyed will result in undefined behavior!</p> Example<pre><code>#include &lt;phoenix/archive.hh&gt;\nint main(int, const char** argv) {\nauto buf = phoenix::buffer::mmap(\"A.ZEN\");\n[[maybe_unused]] auto archive = phoenix::archive_reader::open(buf);\nreturn 0;\n}\n</code></pre>"},{"location":"library/formats/archive/#reading-from-an-archive","title":"Reading from an archive","text":"<p>phoenix implementation of ZenGin Archives is very bare-bones and does not provide a very rich interface. phoenix will automatically determine the kind of archive but that's about it. Reading more data from it requires knowing the format you will be reading beforehand, no buffering or preloading of data is done. A more detailed explanation and demonstration can be found in the example below.</p> Example<pre><code>#include &lt;phoenix/archive.hh&gt;\n#include &lt;iostream&gt;\nint main(int, const char** argv) {\n// First, open the archive\nauto buf = phoenix::buffer::mmap(\"WORLD.ZEN\");\nauto zen = phoenix::archive_reader::open(buf);\n// Second, read the definition of the root object.\n//   Every archive has one object at its root which can be used to\n//   identify what kind of data it is storing.\nphoenix::archive_object object {};\nif (!zen.read_object_begin(object)) {\n// If no object begins at the current position `read_object_begin`\n// will return `false`.\nstd::cerr &lt;&lt; \"The root object was not found.\\n\";\nreturn -1;\n}\n// Here, for example, we're checking whether the root object is a\n// serialized game world.\nif (object.class_name != \"oCWorld:zCWorld\") {\nstd::cerr &lt;&lt; \"This archive does not contain a serialized game world.\\n\";\nreturn -1;\n}\n// From now on, we need to know the format worlds come in. It is not documented here\n// but if necessary, the format of most objects can be found in phoenix' source code.\n//\n// In this case, we know that worlds contain three sub-objects, one describing the\n// world mesh, one containing the way-net and one containing all dynamic objects in\n// the world.\nwhile (!zen.read_object_end()) {\n// `read_object_end` is used to read the end of an object. If it returns `false`,\n// no object ends at the current position. It is required to `read_object_end`\n// after reading all entries in that object.\nzen.read_object_begin(object);\nif (object.object_name == \"VobTree\") {\n// Here, we're only interested in finding the sub-object containing the dynamic\n// objects placed into the world.\n// The VOb tree consists of more nested objects, each followed by an integer\n// denoting the number entries following it which should be considered children\n// of the VOb. The first integer denotes the number of root objects in the tree.\n[[maybe_unused]] int root_vobs = zen-&gt;read_int();\nwhile (!zen-&gt;read_object_end()) {\nzen-&gt;read_object_begin(object);\nif (object.class_name == \"zCVob\") {\n// There is a whole system to the class names in the VOb tree but here,\n// to give an example, we're just interested in the basic `zCVob`. Also\n// there is a lot more data saved in the `zCVob` object but I will omit\n// most of it for brevity sake.\n//\n// So here's some of the types supported by archives read from one:\n[[maybe_unused]] auto packed = in.read_int() != 0;\n[[maybe_unused]] auto preset_name = in.read_string();\n[[maybe_unused]] auto bbox = in.read_bbox();\n[[maybe_unused]] auto rotation = in.read_mat3x3();\n[[maybe_unused]] auto position = in.read_vec3();\n[[maybe_unused]] auto vob_name = in.read_string();\n[[maybe_unused]] auto visual_name = in.read_string();\n[[maybe_unused]] auto show_visual = in.read_bool();\n[[maybe_unused]] auto camera_alignment = in.read_enum();\n// As you can see, all fields must be read in order and with the correct type.\n// If the archive contains a field of type `int` but you try to `read_string()`,\n// phoenix will throw an exception (as documented in the docstrings).\n//\n// For the full list of supported types, see the table below this example.\n}\nif (!zen-&gt;read_object_end()) {\n// (see below for an explanation)\nzen-&gt;skip_object(true);\n}\n}\n}\n// Now, we read the end of the current object.\nif (!zen-&gt;read_object_end()) {\n// But since this small example cannot parse the `WayNet` and `MeshAndBsp`\n// objects of the world, we need to still make sure that the parser is in\n// a sane state. `skip_object` can be used to fully ignore the next object\n// in the archive or, if passed `true`, the object the parser is currently in.\n//\n// We pass `true` here, since we've already `read_object_begin` so the\n// parser is now considered to be in the object we want to skip. Here, skipping\n// the current object also has another great bonus: if, for some reason, one\n// of the objects was not fully parsed, the remaining entries will be skipped\n// so the parser is in a good state for the next iteration of the loop.\nzen-&gt;skip_object(true);\n}\n}\nreturn 0;\n}\n</code></pre> <p>Supported datatypes:</p> Type Name Read Function Description <code>string</code> <code>read_string</code> A Windows-1252 encoded std::string <code>int</code> <code>read_int</code> A 32-bit signed integer <code>float</code> <code>read_float</code> An IEEE 754 floating point number <code>byte</code> <code>read_byte</code> An 8-bit unsigned integer <code>word</code> <code>read_word</code> A 16-bit unsigned integer <code>enum</code> <code>read_enum</code> A 32-bit unsigned integer <code>bool</code> <code>read_bool</code> A boolean value <code>color</code> <code>read_color</code> An <code>RGBA</code> color quad <code>vec3</code> <code>read_vec3</code> A 3-dimensional vector with floating point values <code>rawFloat</code> <code>read_bbox</code>, <code>read_mat3x3</code>, <code>read_vec2</code> A mathematical structure consisting of multiple floating point values <code>raw</code> <code>read_raw_bytes</code> A set of raw bytes, returned as a <code>phoenix::buffer</code>"},{"location":"library/formats/font/","title":"ZenGin Fonts","text":"<p>Fonts for use by the ZenGin are saved in a custom format which maps sections of an image to each character of the alphabet. To that end, each font contains 256 glyphs which correspond to the characters of the Windows-1252 character encoding. For example, the glyph at index <code>0xE4</code> corresponds to the character <code>\u00e4</code>.</p>"},{"location":"library/formats/font/#overview","title":"Overview","text":"<p>phoenix' implementation of fonts lives in <code>include/phoenix/font.hh</code> and <code>source/font.cc</code>. Every font contains the name of the image containing the appearances of each glyph as well as a list of glyphs. Each glyph contains two coordinates which together form a rectangle around the glyph in the image. See Dealing with glyphs for more details</p>"},{"location":"library/formats/font/#loading-a-font","title":"Loading a Font","text":"<p>Like most data structures in phoenix, fonts can be loaded using the <code>phoenix::font::parse()</code> function. It takes a <code>phoenix::buffer</code> as a parameter and loads the font from it.</p> Example<pre><code>#include &lt;phoenix/font.hh&gt;\nint main(int, const char** argv) {\nauto font_buffer = phoenix::buffer::mmap(\"A.fnt\");\n[[maybe_unused]] auto font = phoenix::font::parse(font_buffer);\nreturn 0;\n}\n</code></pre>"},{"location":"library/formats/font/#dealing-with-glyphs","title":"Dealing with glyphs","text":"<p>To render a font, first the font Texture must be loaded. Its name is saved in the <code>phoenix::font::name</code> variable. Each of the 256 glyphs of the font then contains two UV-coordinates denoting the top and bottom corner of a subsection of said texture. These UV-coordinates are between 0 and 1, so they have to be scaled to the actual width and height of the image by multiplying them. The subsection contains the actual image data for the glyph.</p> <p>Since each glyph is saved at the same index as the number representation of its character in Windows-1252, to get the glyph for the character <code>'a'</code>, one can just <code>font.glyphs[(int) 'a']</code> to get the correct glyph name, assuming that <code>'a'</code> follows  Windows-1252 encoding.</p> Example<pre><code>#include &lt;phoenix/font.hh&gt;\n#include &lt;phoenix/texture.hh&gt;\nint main(int, const char** argv) {\nauto font_buffer = phoenix::buffer::mmap(\"A.fnt\");\nauto font = phoenix::font::parse(font_buffer)\n// The texture is loaded from some other location, probably the `Textures.vdf` file.\nauto font_texture = phoenix::texture::parse(phoenix::buffer::mmap(font.name));\nphoenix::glyph glyph0 = font.glyphs[0];\n// Each UV coordinate contains a value from 0 to 1 which is mapped to the actual with and height of the image\nint actual_top_x = glyph0.uv[0].x * font_texture.width();\nint actual_top_y = glyph0.uv[0].y * font_texture.height();\nint actual_bottom_x = glyph0.uv[1].x * font_texture.width();\nint actual_bottom_y = glyph0.uv[1].y * font_texture.height();\nreturn 0;\n}\n</code></pre>"},{"location":"library/formats/vdf/","title":"ZenGin Virtual File System","text":"<p>Virtual Disk Files (or <code>VDFs</code>) are container files like ZIP or, more accurately TAR. A VDF contains a directory structure with multiple files within it. Originally, Gothic and Gothic II used a library called PhysicsFS to load these files and read from them. While PhysicsFS now supports VDFs out-of-the-box, phoenix implements its own, modern parser for them. This page provides a high-level overview of the VDF implementation in phoenix.</p> <p>The original VDF implementation shipped with Gothic and Gothic II was not written by Piranha Bytes themselves but by a now defunct company called TRIACOM Software.</p>"},{"location":"library/formats/vdf/#overview","title":"Overview","text":"<p>phoenix' implementation of VDFs lives in <code>include/phoenix/vdfs.hh</code> and <code>source/vdfs.cc</code>. The most important data structure here is <code>phoenix::vdf_file</code>. It contains the root entries of the VDF and its header. Each entry in a VDF is represented by the <code>phoenix::vdf_entry</code> class and each entry can have multiple child entries.</p>"},{"location":"library/formats/vdf/#loading-a-vdf-file","title":"Loading a VDF file","text":"<p>Unlike most data structures in phoenix, VDF files can be loaded using the <code>phoenix::vdf_file::open()</code> function. It takes either a <code>std::filesystem::path</code> or a <code>phoenix::buffer</code> and loads the VDF from it.</p> Example<pre><code>#include &lt;phoenix/vdfs.hh&gt;\nint main(int, const char** argv) {\n[[maybe_unused]] auto vdf = phoenix::vdf_file::open(\"A.vdf\");\nreturn 0;\n}\n</code></pre>"},{"location":"library/formats/vdf/#accessing-vdf-entries","title":"Accessing VDF entries","text":"<p>There are two ways of accessing the entries of a VDF. The <code>phoenix::vdf_file::find_entry()</code> method can be used to find an entry with the given name anywhere in the VDF while the <code>phoenix::vdf_file::resolve_path()</code> method can be used to find the entry at the given path. Both of these methods will return a <code>phoenix::vdf_entry*</code> which will be <code>nullptr</code> if the entry was not found.</p> <p>Note that <code>find_entry</code> will only ever return the first result it finds. Which result is the first depends on the way the VDF was created and in which order entries were written. If you know that there are two files with the same name in a VDF, you can use <code>resolve_path</code> to explicitly select the one you want.</p> Example<pre><code>#include &lt;phoenix/vdfs.hh&gt;\nint main(int, const char** argv) {\nauto vdf = phoenix::vdf_file::open(\"A.vdf\");\n[[maybe_unused]] auto* found_entry = vdf.find_entry(\"SomeFile.txt\");\n[[maybe_unused]] auto* resolved_entry = vdf.resolve_entry(\"some/other/path/SomeFile.txt\");\nreturn 0;\n}\n</code></pre>"},{"location":"library/formats/vdf/#merging-vdfs","title":"Merging VDFs","text":"<p>Another feature of phoenix' implementation of VDFs is merging. Sometimes it is necessary or convenient to merge multiple VDFs into one. In Gothic, for example, there are multiple different VDFs containing texture data:</p> <ul> <li><code>textures_apostroph_patch_neu.VDF</code>,</li> <li><code>textures_choicebox_32pixel_modialpha.VDF</code>,</li> <li><code>textures_patch.VDF</code>,</li> <li><code>textures_Startscreen_ohne_Logo.VDF</code> and</li> <li><code>textures.VDF</code>.</li> </ul> <p>Some of them contain textures meant to be patches and some just add new textures. You can merge them together to easily access all of the files using a single <code>phoenix::vdf_file</code> instance using <code>phoenix::vdf_file::merge()</code>.</p> <p>Danger</p> <p>The <code>merge()</code> implementation currently does not work properly when replacing files. To make sure only the newest file in a given VDF is kept, you have to order the VDFs by date before merging them.</p> Example<pre><code>#include &lt;phoenix/vdfs.hh&gt;\nint main(int, const char** argv) {\nauto vdf_a = phoenix::vdf_file::open(\"A.vdf\");\nauto vdf_b = phoenix::vdf_file::open(\"Another.vdf\");\nvdf_a.merge(vdf_b, false);\n// both VDFs remain valid on their own but vdf_a now also contains non-duplicate entries of vdf_b.\nreturn 0;\n}\n</code></pre>"}]}